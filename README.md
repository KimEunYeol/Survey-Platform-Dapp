
## 1. 개요

- 설문조사는 미리 구성한 질문과 답변을 이용해 대상으로부터 응답을 받아 결과를 도출해내는 보편적이고 효과 적인 수단이다. 
- 본 시스템은 웹 페이지와 모바일 어플리케이션을 이용해 쉽게 설문조사를 생성 및 참여 할 수 있 는 기능을 제공한다.
- 모든 설문 정보는 스마트 계약(Smart Contract)을 통해 블록 체인 네트워크를 구성하고 있는 피 어에 의해 검증되고 저장되어 위ㆍ변조가 불가능 하다
- 설문에 응답한 사용자는 보상으로 암호 화폐(Crypto Currency) 혹은 토큰(Token)을 지급받아 재화로 사용 할 수 있다.
- 설문의 투명성을 보장함과 동시에 설문조사에 참여율을 높여 설문조사에 대한 신뢰성을 높일 수 있는 플랫폼 시스템을 제안한다.

- - -

## 2. 사용기술 및 개발환경

![image](https://user-images.githubusercontent.com/38580908/82654356-8ffe8300-9c5b-11ea-8c45-839021e7a278.png)

#### 2.1 이더리움
- 이더리움은 블록체인 기술을 기반으로 스마트 계약 기능을 구현하기 위한 분산 컴퓨팅 플랫폼이다. 이더리움은 비트코인과 마찬가지로 이더(Ether)라는 암호 화폐 기능을 제공하고 있으며 화폐 거래 기록 뿐 아니라 계약 등의 추가 정보를 기록할 수 있는 장점이 있다.

#### 2.1.1 스마트 계약
- 스마트 계약은 계약의 협상 또는 체결을 디지털 방식으로 검증과 강제하는  컴퓨터 프로토콜이다. 비트코인은 결제, 송금 등 화폐 거래를 기록했었지만 이후의 블록체인 플랫폼에서는 스마트 계약을 사용해 블록체인의 활용을 더 확장시켰다. 정해진 계약 조건이 성립하면 자동으로 실행되기 때문에 개발자는 스마트 계약에 계약 성립 조건을 이용해 분산형 어플리케이션을 개발할 수 있다.

#### 2.1.2 토큰
- 이더리움은 Dapp에서 사용될 수 있는 스마트 계약을 통한 ERC20, ERC721 토큰을 지원한다.  ERC20 토큰은 현실에서 사용 되는 화폐와 같은 대체 가능한 암호 화폐이다.  내가 가진 10토큰과 다른 사람이 가진 10토큰은 동일한 가치를 지닌다는 말과 같다. ERC721 토큰은 반대로 각 토큰이 다른 가치를 가지고 있는 대체 불가능한 화폐이다.

#### 2.1.3 지갑(MetaMask)
- 지갑은 사용자가 소유한 암호 화폐를 보관하고 관리하는 기능을 제공하는 프로그램이다. 이더와 ERC20토큰을 지갑에서 사용할 수 있다.
  Dapp은 지갑을 이용해 화폐를 거래하거나 스마트 계약을 할 수 있다. 이더리움의 대표적인 지갑은 MetaMask로 웹 브라우저의 확장 프로그램 설치만으로 사용이 가능해서 많은 Dapp에서 사용 중이다.

#### 2.1.4 RPC
- 이더리움은 Geth를 통한 CLI 환경에서 명령어를 사용할 수 있다. 다른 어플리케이션에서 이더리움 노드의 명령을 수행하게 할 수 있도록 이더리움은 JSON RPC를 지원한다. 지갑과 Dapp 역시 RPC를 이용해 이더리움을 사용한다. RPC 통신을 더 편리하게 사용하고자 이더리움에서는 이후 언급할 web3라는 라이브러리를 공식 제공하고 있다.

#### 2.2 마이닝(Mining)
#### 2.2.1 채굴
- 거래 기록이 담긴 블록을 검증이 필요하다. 이 과정을 ‘채굴’이라 표현하는데 블록의 정보와 임의의 숫자를 이용해 블록을 검증한다. 이 때 많은 컴퓨팅 자원을 필요로 하기 때문에 검증에 가장 먼저 성공한 참여자는 이더로 보상을 받게 된다.

#### 2.2.2 합의 알고리즘(Consensus Algorithm)
- 이더리움은 합의 알고리즘으로 PoW를 사용한다. PoW는 블록의 검증 방법 중 하나로 “채굴자가 블록의 무결성을 확인했다는 것을 증명”하는 행위이다.

#### 2.3 언어
#### 2.3.1 Solidity
- Solidity는 이더리움의 스마트 계약 개발에 사용 되는 언어이다. 컴파일 결과로 바이트 코드와 ABI(Application Binary Interface)가 생성되는데 이를 이용해 이더리움에 배포하여 스마트 계약을 사용할 수 있다.
#### 2.3.2 web3.js
- web3.js는 이더리움이 공식적으로 지원하는 RPC 라이브러리인 web3의 자바스크립트용 SDK이다. 웹 기반의 Dapp을 개발할 때 프론트 엔드와 백 엔드 모두에 사용할 수 있어 자주 사용된다.

- - -

## 3. 제안 플랫폼
![image](https://user-images.githubusercontent.com/38580908/82654732-2468e580-9c5c-11ea-881a-7842a5718cba.png)

- Step 1. 스마트 계약 작성/배포 solidity를 이용한 스마트 계약 작성 블록체인 네트워크에 배포
- Step 2. 사용자/스마트 계약에 의한 트랜잭션 발생 Dapp을 통한 트랜잭션 발생
- Step 3. 노드들에 의한 검증(Confirmation) 노드들이 동일한 데이터 보유 ⇒ 데이터 투명성/신뢰성 보장

</br>

설문조사 생성의 경우 아래 사진과 같이 사용자는 설문조사 생성을 위해 제목, 총 보상 량, 보상 량에 대한 데이터를 입력하여야 하며 여기서 총 보상 량이란 설문조사에 모두 응답한 사용자에게 주어지는 보상 량의 총합을 뜻한다.
사용자가 총 보상 5이더(5Eth)를 설문조사 생성 및 배포자가 지불하고 응답자에게 각 0.05이더를 보상하는 설문조사를 생성하는 화면이다.
![image](https://user-images.githubusercontent.com/38580908/82655228-d3a5bc80-9c5c-11ea-956e-20e026cf2e38.png)

</br>
아래 사진에서는 사용자가 설문조사를 생성했을 때 사용자의 지갑으로부터 보상 이더와 수수료를 지불하는 것을 보여주는 블록체인 암호 화폐 지갑 화면이다.
![image](https://user-images.githubusercontent.com/38580908/82656573-f2a54e00-9c5e-11ea-8d3d-7b09544825ae.png)

</br>
다음으로 설문을 생성한 사용자는 각 설문 문항을 추가해야 한다. 질의 하고자하는 문항을 입력하고 그에 대한 답안을 기입하여 설문 문항을 완성한다. 사진은 설문 문항 추가하기 위한 화면이다. 
![image](https://user-images.githubusercontent.com/38580908/82656578-f507a800-9c5e-11ea-8fe3-7cede845b0ee.png)

</br>
마지막으로 설문 문항 추가 작업을 모두 마치고 나면 설문조사가 생성된다. 아래 사진에서는 위 절차를 통해 생성한 설문조사가 실제 응답자에게 보여 지는 화면이다. 각 문항에 대한 결과는 도넛차트 통해 실시간으로 확인 할 수 있으며, 응답자는 각각의 설문 문항에 대해 적절한 선택지를 선택 후 제출하면 설문이 완료된다. 이로써 응답자는 0.05이더의 보상을 획득하게 되며, 완료된 설문의 데이터는 스마트 계약에 저장 된다.
![image](https://user-images.githubusercontent.com/38580908/82656584-f8029880-9c5e-11ea-9e59-33837561fa8c.png)

## 4. 핵심코드
Input : 설문제목, 보상수량
Output : 사용자 설문조사
Describe : 일정 보상을 지급하는 설문조사 생성 Tx발생
~~~javascript
function createSurvey(bytes32 _title, uint _reward) public payable 
  address addr = (new Survey).value(msg.value)(_reward);
  title[addr] = _title;  surveys.push(addr);
  emit Created(addr);
~~~

Input : 문항에 대한 응답
Output : -
Describe : 각 설문에 대한 응답을 해당 계약에 저장
~~~javascript
function participate(bytes32[] _response) public payable
  require(address(this).balance > reward);
  require(questions.length == _response.length);
  require(!logs[msg.sender].isExist);
  logs[msg.sender].answers = _response;
  logs[msg.sender].isExist = true;
  for (uint i=0; i<_response.length; i++)
    questionMapping[questions[i]]
      .answerMapping[_response[i]]++;}
  msg.sender.transfer(reward);
~~~
